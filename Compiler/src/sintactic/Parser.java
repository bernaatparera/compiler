
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package sintactic;

import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.*;
import sintactic.Symbols.*;
import assemblyCode.*;
import threeAddressCode.*;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Objects;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class Parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return ParserSym.class;
}

  /** Default constructor. */
  @Deprecated
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\154\000\002\002\004\000\002\002\010\000\002\056" +
    "\002\000\002\017\004\000\002\017\002\000\002\016\004" +
    "\000\002\016\002\000\002\015\004\000\002\015\004\000" +
    "\002\015\004\000\002\015\004\000\002\015\004\000\002" +
    "\015\004\000\002\015\003\000\002\015\003\000\002\015" +
    "\003\000\002\057\002\000\002\060\002\000\002\030\003" +
    "\000\002\032\007\000\002\032\006\000\002\036\003\000" +
    "\002\036\003\000\002\037\005\000\002\040\003\000\002" +
    "\040\003\000\002\040\003\000\002\034\003\000\002\034" +
    "\003\000\002\035\003\000\002\035\003\000\002\035\003" +
    "\000\002\003\004\000\002\042\005\000\002\042\004\000" +
    "\002\061\002\000\002\020\011\000\002\043\005\000\002" +
    "\043\003\000\002\043\002\000\002\025\004\000\002\007" +
    "\005\000\002\007\003\000\002\031\003\000\002\051\006" +
    "\000\002\010\004\000\002\010\002\000\002\047\003\000" +
    "\002\006\005\000\002\006\002\000\002\004\006\000\002" +
    "\012\003\000\002\012\003\000\002\045\006\000\002\046" +
    "\010\000\002\050\003\000\002\050\003\000\002\044\006" +
    "\000\002\013\005\000\002\013\002\000\002\005\006\000" +
    "\002\014\004\000\002\041\005\000\002\041\005\000\002" +
    "\041\005\000\002\041\005\000\002\041\005\000\002\041" +
    "\005\000\002\041\005\000\002\041\005\000\002\041\005" +
    "\000\002\041\005\000\002\041\005\000\002\041\005\000" +
    "\002\041\005\000\002\041\005\000\002\041\005\000\002" +
    "\041\005\000\002\041\003\000\002\041\004\000\002\041" +
    "\003\000\002\041\004\000\002\041\003\000\002\041\003" +
    "\000\002\041\004\000\002\041\004\000\002\041\004\000" +
    "\002\027\003\000\002\027\003\000\002\027\003\000\002" +
    "\021\004\000\002\052\012\000\002\052\010\000\002\022" +
    "\007\000\002\022\005\000\002\022\002\000\002\024\012" +
    "\000\002\023\004\000\002\055\013\000\002\026\005\000" +
    "\002\011\003\000\002\011\002\000\002\062\002\000\002" +
    "\033\004\000\002\033\003\000\002\063\002\000\002\053" +
    "\004\000\002\054\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\317\000\004\004\004\001\002\000\004\015\007\001" +
    "\002\000\004\002\006\001\002\000\004\002\001\001\002" +
    "\000\004\052\010\001\002\000\036\004\uffff\005\uffff\006" +
    "\uffff\007\uffff\010\uffff\012\uffff\013\uffff\014\uffff\020\uffff" +
    "\021\uffff\022\uffff\023\uffff\053\uffff\054\uffff\001\002\000" +
    "\036\004\023\005\017\006\035\007\034\010\024\012\052" +
    "\013\014\014\040\020\044\021\031\022\036\023\030\053" +
    "\ufffd\054\042\001\002\000\004\050\311\001\002\000\004" +
    "\046\310\001\002\000\004\050\301\001\002\000\004\050" +
    "\261\001\002\000\040\004\ufff2\005\ufff2\006\ufff2\007\ufff2" +
    "\010\ufff2\011\ufff2\012\ufff2\013\ufff2\014\ufff2\020\ufff2\021" +
    "\ufff2\022\ufff2\023\ufff2\053\ufff2\054\ufff2\001\002\000\004" +
    "\050\uffce\001\002\000\004\050\256\001\002\000\040\004" +
    "\uffa9\005\uffa9\006\uffa9\007\uffa9\010\uffa9\011\uffa9\012\uffa9" +
    "\013\uffa9\014\uffa9\020\uffa9\021\uffa9\022\uffa9\023\uffa9\053" +
    "\uffa9\054\uffa9\001\002\000\004\046\255\001\002\000\010" +
    "\020\044\021\031\054\253\001\002\000\004\050\241\001" +
    "\002\000\040\004\uffaa\005\uffaa\006\uffaa\007\uffaa\010\uffaa" +
    "\011\uffaa\012\uffaa\013\uffaa\014\uffaa\020\uffaa\021\uffaa\022" +
    "\uffaa\023\uffaa\053\uffaa\054\uffaa\001\002\000\004\024\225" +
    "\001\002\000\040\004\ufff4\005\ufff4\006\ufff4\007\ufff4\010" +
    "\ufff4\011\ufff4\012\ufff4\013\ufff4\014\ufff4\020\ufff4\021\ufff4" +
    "\022\ufff4\023\ufff4\053\ufff4\054\ufff4\001\002\000\004\050" +
    "\222\001\002\000\004\054\uffe5\001\002\000\040\004\uffa2" +
    "\005\uffa2\006\uffa2\007\uffa2\010\uffa2\011\213\012\uffa2\013" +
    "\uffa2\014\uffa2\020\uffa2\021\uffa2\022\uffa2\023\uffa2\053\uffa2" +
    "\054\uffa2\001\002\000\004\054\ufff1\001\002\000\016\016" +
    "\074\017\073\026\100\041\075\054\101\056\076\001\002" +
    "\000\004\050\uffcd\001\002\000\004\054\072\001\002\000" +
    "\004\052\165\001\002\000\006\020\044\021\031\001\002" +
    "\000\004\046\155\001\002\000\006\024\uffef\050\uffd6\001" +
    "\002\000\004\046\154\001\002\000\004\054\uffe6\001\002" +
    "\000\036\004\023\005\017\006\035\007\034\010\024\012" +
    "\052\013\014\014\040\020\044\021\031\022\036\023\030" +
    "\053\ufffb\054\042\001\002\000\004\046\150\001\002\000" +
    "\004\046\147\001\002\000\040\004\ufff3\005\ufff3\006\ufff3" +
    "\007\ufff3\010\ufff3\011\ufff3\012\ufff3\013\ufff3\014\ufff3\020" +
    "\ufff3\021\ufff3\022\ufff3\023\ufff3\053\ufff3\054\ufff3\001\002" +
    "\000\040\004\uffa8\005\uffa8\006\uffa8\007\uffa8\010\uffa8\011" +
    "\uffa8\012\uffa8\013\uffa8\014\uffa8\020\uffa8\021\uffa8\022\uffa8" +
    "\023\uffa8\053\uffa8\054\uffa8\001\002\000\004\050\055\001" +
    "\002\000\004\053\054\001\002\000\004\002\000\001\002" +
    "\000\012\014\uffff\020\uffff\021\uffff\047\uffff\001\002\000" +
    "\012\014\040\020\044\021\031\047\uff9c\001\002\000\004" +
    "\047\uff9d\001\002\000\004\047\061\001\002\000\016\016" +
    "\uff98\017\uff98\026\uff98\041\uff98\054\uff98\056\uff98\001\002" +
    "\000\016\016\074\017\073\026\100\041\075\054\101\056" +
    "\076\001\002\000\004\047\065\001\002\000\004\047\uff96" +
    "\001\002\000\006\051\uff9b\054\uff9b\001\002\000\006\051" +
    "\uff99\054\072\001\002\000\004\051\070\001\002\000\004" +
    "\052\uff9f\001\002\000\004\051\uff9a\001\002\000\006\024" +
    "\uffef\052\uffef\001\002\000\050\025\uffae\026\uffae\027\uffae" +
    "\030\uffae\031\uffae\032\uffae\033\uffae\034\uffae\035\uffae\036" +
    "\uffae\037\uffae\040\uffae\042\uffae\043\uffae\044\uffae\045\uffae" +
    "\046\uffae\047\uffae\051\uffae\001\002\000\050\025\uffaf\026" +
    "\uffaf\027\uffaf\030\uffaf\031\uffaf\032\uffaf\033\uffaf\034\uffaf" +
    "\035\uffaf\036\uffaf\037\uffaf\040\uffaf\042\uffaf\043\uffaf\044" +
    "\uffaf\045\uffaf\046\uffaf\047\uffaf\051\uffaf\001\002\000\010" +
    "\016\145\017\144\054\146\001\002\000\050\025\uffb1\026" +
    "\uffb1\027\uffb1\030\uffb1\031\uffb1\032\uffb1\033\uffb1\034\uffb1" +
    "\035\uffb1\036\uffb1\037\uffb1\040\uffb1\042\uffb1\043\uffb1\044" +
    "\uffb1\045\uffb1\046\uffb1\047\uffb1\051\uffb1\001\002\000\046" +
    "\025\121\026\117\027\123\030\106\031\114\032\112\033" +
    "\107\034\120\035\115\036\104\037\113\040\111\042\116" +
    "\043\122\044\110\045\105\047\uff97\051\uff97\001\002\000" +
    "\006\054\103\056\102\001\002\000\050\025\uffb3\026\uffb3" +
    "\027\uffb3\030\uffb3\031\uffb3\032\uffb3\033\uffb3\034\uffb3\035" +
    "\uffb3\036\uffb3\037\uffb3\040\uffb3\042\uffb3\043\uffb3\044\uffb3" +
    "\045\uffb3\046\uffb3\047\uffb3\051\uffb3\001\002\000\050\025" +
    "\uffb0\026\uffb0\027\uffb0\030\uffb0\031\uffb0\032\uffb0\033\uffb0" +
    "\034\uffb0\035\uffb0\036\uffb0\037\uffb0\040\uffb0\042\uffb0\043" +
    "\uffb0\044\uffb0\045\uffb0\046\uffb0\047\uffb0\051\uffb0\001\002" +
    "\000\050\025\uffb2\026\uffb2\027\uffb2\030\uffb2\031\uffb2\032" +
    "\uffb2\033\uffb2\034\uffb2\035\uffb2\036\uffb2\037\uffb2\040\uffb2" +
    "\042\uffb2\043\uffb2\044\uffb2\045\uffb2\046\uffb2\047\uffb2\051" +
    "\uffb2\001\002\000\016\016\074\017\073\026\100\041\075" +
    "\054\101\056\076\001\002\000\016\016\074\017\073\026" +
    "\100\041\075\054\101\056\076\001\002\000\016\016\074" +
    "\017\073\026\100\041\075\054\101\056\076\001\002\000" +
    "\016\016\074\017\073\026\100\041\075\054\101\056\076" +
    "\001\002\000\016\016\074\017\073\026\100\041\075\054" +
    "\101\056\076\001\002\000\016\016\074\017\073\026\100" +
    "\041\075\054\101\056\076\001\002\000\016\016\074\017" +
    "\073\026\100\041\075\054\101\056\076\001\002\000\016" +
    "\016\074\017\073\026\100\041\075\054\101\056\076\001" +
    "\002\000\016\016\074\017\073\026\100\041\075\054\101" +
    "\056\076\001\002\000\016\016\074\017\073\026\100\041" +
    "\075\054\101\056\076\001\002\000\016\016\074\017\073" +
    "\026\100\041\075\054\101\056\076\001\002\000\016\016" +
    "\074\017\073\026\100\041\075\054\101\056\076\001\002" +
    "\000\016\016\074\017\073\026\100\041\075\054\101\056" +
    "\076\001\002\000\016\016\074\017\073\026\100\041\075" +
    "\054\101\056\076\001\002\000\016\016\074\017\073\026" +
    "\100\041\075\054\101\056\076\001\002\000\016\016\074" +
    "\017\073\026\100\041\075\054\101\056\076\001\002\000" +
    "\050\025\uffc1\026\uffc1\027\uffc1\030\uffc1\031\uffc1\032\uffc1" +
    "\033\uffc1\034\uffc1\035\uffc1\036\uffc1\037\uffc1\040\uffc1\042" +
    "\uffc1\043\uffc1\044\uffc1\045\uffc1\046\uffc1\047\uffc1\051\uffc1" +
    "\001\002\000\050\025\121\026\117\027\123\030\106\031" +
    "\114\032\112\033\107\034\120\035\115\036\104\037\uffbc" +
    "\040\uffbc\042\uffbc\043\uffbc\044\uffbc\045\uffbc\046\uffbc\047" +
    "\uffbc\051\uffbc\001\002\000\050\025\uffc3\026\uffc3\027\123" +
    "\030\106\031\uffc3\032\uffc3\033\uffc3\034\uffc3\035\uffc3\036" +
    "\uffc3\037\uffc3\040\uffc3\042\uffc3\043\uffc3\044\uffc3\045\uffc3" +
    "\046\uffc3\047\uffc3\051\uffc3\001\002\000\050\025\121\026" +
    "\117\027\123\030\106\031\uffb6\032\uffb6\033\uffb6\034\uffb6" +
    "\035\uffb6\036\uffb6\037\uffb6\040\uffb6\042\uffb6\043\uffb6\044" +
    "\uffb6\045\uffb6\046\uffb6\047\uffb6\051\uffb6\001\002\000\050" +
    "\025\uffc2\026\uffc2\027\123\030\106\031\uffc2\032\uffc2\033" +
    "\uffc2\034\uffc2\035\uffc2\036\uffc2\037\uffc2\040\uffc2\042\uffc2" +
    "\043\uffc2\044\uffc2\045\uffc2\046\uffc2\047\uffc2\051\uffc2\001" +
    "\002\000\050\025\121\026\117\027\123\030\106\031\114" +
    "\032\112\033\107\034\120\035\115\036\104\037\uffbd\040" +
    "\uffbd\042\uffbd\043\uffbd\044\uffbd\045\uffbd\046\uffbd\047\uffbd" +
    "\051\uffbd\001\002\000\050\025\121\026\117\027\123\030" +
    "\106\031\uffb5\032\uffb5\033\uffb5\034\uffb5\035\uffb5\036\uffb5" +
    "\037\uffb5\040\uffb5\042\uffb5\043\uffb5\044\uffb5\045\uffb5\046" +
    "\uffb5\047\uffb5\051\uffb5\001\002\000\050\025\121\026\117" +
    "\027\123\030\106\031\uffb9\032\uffb9\033\uffb9\034\uffb9\035" +
    "\uffb9\036\uffb9\037\uffb9\040\uffb9\042\uffb9\043\uffb9\044\uffb9" +
    "\045\uffb9\046\uffb9\047\uffb9\051\uffb9\001\002\000\050\025" +
    "\121\026\117\027\123\030\106\031\114\032\112\033\107" +
    "\034\120\035\115\036\104\037\uffbf\040\uffbf\042\uffbf\043" +
    "\uffbf\044\uffbf\045\uffbf\046\uffbf\047\uffbf\051\uffbf\001\002" +
    "\000\050\025\121\026\117\027\123\030\106\031\uffb8\032" +
    "\uffb8\033\uffb8\034\uffb8\035\uffb8\036\uffb8\037\uffb8\040\uffb8" +
    "\042\uffb8\043\uffb8\044\uffb8\045\uffb8\046\uffb8\047\uffb8\051" +
    "\uffb8\001\002\000\050\025\121\026\117\027\123\030\106" +
    "\031\114\032\112\033\107\034\120\035\115\036\104\037" +
    "\uffbe\040\uffbe\042\uffbe\043\uffbe\044\uffbe\045\uffbe\046\uffbe" +
    "\047\uffbe\051\uffbe\001\002\000\050\025\121\026\117\027" +
    "\123\030\106\031\114\032\112\033\107\034\120\035\115" +
    "\036\104\037\uffbb\040\uffbb\042\uffbb\043\uffbb\044\uffbb\045" +
    "\uffbb\046\uffbb\047\uffbb\051\uffbb\001\002\000\050\025\121" +
    "\026\117\027\123\030\106\031\uffb7\032\uffb7\033\uffb7\034" +
    "\uffb7\035\uffb7\036\uffb7\037\uffb7\040\uffb7\042\uffb7\043\uffb7" +
    "\044\uffb7\045\uffb7\046\uffb7\047\uffb7\051\uffb7\001\002\000" +
    "\050\025\uffc0\026\uffc0\027\uffc0\030\uffc0\031\uffc0\032\uffc0" +
    "\033\uffc0\034\uffc0\035\uffc0\036\uffc0\037\uffc0\040\uffc0\042" +
    "\uffc0\043\uffc0\044\uffc0\045\uffc0\046\uffc0\047\uffc0\051\uffc0" +
    "\001\002\000\050\025\121\026\117\027\123\030\106\031" +
    "\114\032\112\033\107\034\120\035\115\036\104\037\uffba" +
    "\040\uffba\042\uffba\043\uffba\044\uffba\045\uffba\046\uffba\047" +
    "\uffba\051\uffba\001\002\000\050\025\121\026\117\027\123" +
    "\030\106\031\uffb4\032\uffb4\033\uffb4\034\uffb4\035\uffb4\036" +
    "\uffb4\037\uffb4\040\uffb4\042\uffb4\043\uffb4\044\uffb4\045\uffb4" +
    "\046\uffb4\047\uffb4\051\uffb4\001\002\000\050\025\uffab\026" +
    "\uffab\027\uffab\030\uffab\031\uffab\032\uffab\033\uffab\034\uffab" +
    "\035\uffab\036\uffab\037\uffab\040\uffab\042\uffab\043\uffab\044" +
    "\uffab\045\uffab\046\uffab\047\uffab\051\uffab\001\002\000\050" +
    "\025\uffac\026\uffac\027\uffac\030\uffac\031\uffac\032\uffac\033" +
    "\uffac\034\uffac\035\uffac\036\uffac\037\uffac\040\uffac\042\uffac" +
    "\043\uffac\044\uffac\045\uffac\046\uffac\047\uffac\051\uffac\001" +
    "\002\000\050\025\uffad\026\uffad\027\uffad\030\uffad\031\uffad" +
    "\032\uffad\033\uffad\034\uffad\035\uffad\036\uffad\037\uffad\040" +
    "\uffad\042\uffad\043\uffad\044\uffad\045\uffad\046\uffad\047\uffad" +
    "\051\uffad\001\002\000\040\004\ufff9\005\ufff9\006\ufff9\007" +
    "\ufff9\010\ufff9\011\ufff9\012\ufff9\013\ufff9\014\ufff9\020\ufff9" +
    "\021\ufff9\022\ufff9\023\ufff9\053\ufff9\054\ufff9\001\002\000" +
    "\040\004\ufffa\005\ufffa\006\ufffa\007\ufffa\010\ufffa\011\ufffa" +
    "\012\ufffa\013\ufffa\014\ufffa\020\ufffa\021\ufffa\022\ufffa\023" +
    "\ufffa\053\ufffa\054\ufffa\001\002\000\004\053\ufffe\001\002" +
    "\000\036\004\023\005\017\006\035\007\034\010\024\012" +
    "\052\013\014\014\040\020\044\021\031\022\036\023\030" +
    "\053\ufffb\054\042\001\002\000\004\053\ufffc\001\002\000" +
    "\040\004\ufff8\005\ufff8\006\ufff8\007\ufff8\010\ufff8\011\ufff8" +
    "\012\ufff8\013\ufff8\014\ufff8\020\ufff8\021\ufff8\022\ufff8\023" +
    "\ufff8\053\ufff8\054\ufff8\001\002\000\040\004\ufff6\005\ufff6" +
    "\006\ufff6\007\ufff6\010\ufff6\011\ufff6\012\ufff6\013\ufff6\014" +
    "\ufff6\020\ufff6\021\ufff6\022\ufff6\023\ufff6\053\ufff6\054\ufff6" +
    "\001\002\000\004\054\ufff1\001\002\000\004\054\162\001" +
    "\002\000\006\046\uffeb\047\uffeb\001\002\000\006\046\ufff0" +
    "\047\ufff0\001\002\000\010\024\uffef\046\uffec\047\uffec\001" +
    "\002\000\006\046\uffee\047\uffee\001\002\000\040\004\uffa0" +
    "\005\uffa0\006\uffa0\007\uffa0\010\uffa0\011\uffa0\012\uffa0\013" +
    "\uffa0\014\uffa0\020\uffa0\021\uffa0\022\uffa0\023\uffa0\053\uffa0" +
    "\054\uffa0\001\002\000\036\004\023\005\017\006\035\007" +
    "\034\010\024\012\052\013\014\014\040\020\044\021\031" +
    "\022\036\023\030\053\ufffd\054\042\001\002\000\004\053" +
    "\167\001\002\000\040\004\uff9e\005\uff9e\006\uff9e\007\uff9e" +
    "\010\uff9e\011\uff9e\012\uff9e\013\uff9e\014\uff9e\020\uff9e\021" +
    "\uff9e\022\uff9e\023\uff9e\053\uff9e\054\uff9e\001\002\000\004" +
    "\052\171\001\002\000\010\020\174\021\173\022\172\001" +
    "\002\000\004\054\uffe2\001\002\000\004\054\uffe3\001\002" +
    "\000\004\054\uffe4\001\002\000\004\054\177\001\002\000" +
    "\040\004\uffcc\005\uffcc\006\uffcc\007\uffcc\010\uffcc\011\uffcc" +
    "\012\uffcc\013\uffcc\014\uffcc\020\uffcc\021\uffcc\022\uffcc\023" +
    "\uffcc\053\uffcc\054\uffcc\001\002\000\004\024\200\001\002" +
    "\000\016\016\074\017\073\026\100\041\075\054\101\056" +
    "\076\001\002\000\044\025\121\026\117\027\123\030\106" +
    "\031\114\032\112\033\107\034\120\035\115\036\104\037" +
    "\113\040\111\042\116\043\122\044\110\045\105\046\202" +
    "\001\002\000\012\020\174\021\173\022\172\053\203\001" +
    "\002\000\040\004\uffc9\005\uffc9\006\uffc9\007\uffc9\010\uffc9" +
    "\011\uffc9\012\uffc9\013\uffc9\014\uffc9\020\uffc9\021\uffc9\022" +
    "\uffc9\023\uffc9\053\uffc9\054\uffc9\001\002\000\040\004\uffca" +
    "\005\uffca\006\uffca\007\uffca\010\uffca\011\uffca\012\uffca\013" +
    "\uffca\014\uffca\020\uffca\021\uffca\022\uffca\023\uffca\053\uffca" +
    "\054\uffca\001\002\000\040\004\uffcb\005\uffcb\006\uffcb\007" +
    "\uffcb\010\uffcb\011\uffcb\012\uffcb\013\uffcb\014\uffcb\020\uffcb" +
    "\021\uffcb\022\uffcb\023\uffcb\053\uffcb\054\uffcb\001\002\000" +
    "\044\025\121\026\117\027\123\030\106\031\114\032\112" +
    "\033\107\034\120\035\115\036\104\037\113\040\111\042" +
    "\116\043\122\044\110\045\105\046\uffc4\001\002\000\004" +
    "\054\162\001\002\000\006\046\ufff0\047\ufff0\001\002\000" +
    "\006\046\uffed\047\uffed\001\002\000\040\004\uffa7\005\uffa7" +
    "\006\uffa7\007\uffa7\010\uffa7\011\uffa7\012\uffa7\013\uffa7\014" +
    "\uffa7\020\uffa7\021\uffa7\022\uffa7\023\uffa7\053\uffa7\054\uffa7" +
    "\001\002\000\036\004\uffff\005\uffff\006\uffff\007\uffff\010" +
    "\uffff\012\uffff\013\uffff\014\uffff\020\uffff\021\uffff\022\uffff" +
    "\023\uffff\052\214\054\uffff\001\002\000\036\004\uffff\005" +
    "\uffff\006\uffff\007\uffff\010\uffff\012\uffff\013\uffff\014\uffff" +
    "\020\uffff\021\uffff\022\uffff\023\uffff\053\uffff\054\uffff\001" +
    "\002\000\034\004\023\005\017\006\035\007\034\010\024" +
    "\012\052\013\014\014\040\020\044\021\031\022\036\023" +
    "\030\054\042\001\002\000\040\004\uffa3\005\uffa3\006\uffa3" +
    "\007\uffa3\010\uffa3\011\uffa3\012\uffa3\013\uffa3\014\uffa3\020" +
    "\uffa3\021\uffa3\022\uffa3\023\uffa3\053\uffa3\054\uffa3\001\002" +
    "\000\036\004\023\005\017\006\035\007\034\010\024\012" +
    "\052\013\014\014\040\020\044\021\031\022\036\023\030" +
    "\053\ufffd\054\042\001\002\000\004\053\221\001\002\000" +
    "\040\004\uffa4\005\uffa4\006\uffa4\007\uffa4\010\uffa4\011\uffa4" +
    "\012\uffa4\013\uffa4\014\uffa4\020\uffa4\021\uffa4\022\uffa4\023" +
    "\uffa4\053\uffa4\054\uffa4\001\002\000\004\054\223\001\002" +
    "\000\004\051\224\001\002\000\004\046\uffc5\001\002\000" +
    "\016\016\074\017\073\026\100\041\075\054\226\056\076" +
    "\001\002\000\054\025\uffb3\026\uffb3\027\uffb3\030\uffb3\031" +
    "\uffb3\032\uffb3\033\uffb3\034\uffb3\035\uffb3\036\uffb3\037\uffb3" +
    "\040\uffb3\042\uffb3\043\uffb3\044\uffb3\045\uffb3\046\uffb3\047" +
    "\uffb3\050\uffd6\051\uffb3\055\233\001\002\000\010\046\uffea" +
    "\047\uffea\051\uffea\001\002\000\010\046\uffe7\047\uffe7\051" +
    "\uffe7\001\002\000\010\046\uffe8\047\uffe8\051\uffe8\001\002" +
    "\000\050\025\121\026\117\027\123\030\106\031\114\032" +
    "\112\033\107\034\120\035\115\036\104\037\113\040\111" +
    "\042\116\043\122\044\110\045\105\046\uffe9\047\uffe9\051" +
    "\uffe9\001\002\000\004\054\234\001\002\000\012\046\uffc6" +
    "\047\uffc6\051\uffc6\055\235\001\002\000\004\054\237\001" +
    "\002\000\010\046\uffc8\047\uffc8\051\uffc8\001\002\000\012" +
    "\046\uffc6\047\uffc6\051\uffc6\055\235\001\002\000\010\046" +
    "\uffc7\047\uffc7\051\uffc7\001\002\000\016\016\uff98\017\uff98" +
    "\026\uff98\041\uff98\054\uff98\056\uff98\001\002\000\004\051" +
    "\243\001\002\000\036\004\uffff\005\uffff\006\uffff\007\uffff" +
    "\010\uffff\012\uffff\013\uffff\014\uffff\020\uffff\021\uffff\022" +
    "\uffff\023\uffff\052\244\054\uffff\001\002\000\036\004\uffff" +
    "\005\uffff\006\uffff\007\uffff\010\uffff\012\uffff\013\uffff\014" +
    "\uffff\020\uffff\021\uffff\022\uffff\023\uffff\053\uffff\054\uffff" +
    "\001\002\000\034\004\023\005\017\006\035\007\034\010" +
    "\024\012\052\013\014\014\040\020\044\021\031\022\036" +
    "\023\030\054\042\001\002\000\040\004\uffa5\005\uffa5\006" +
    "\uffa5\007\uffa5\010\uffa5\011\uffa5\012\uffa5\013\uffa5\014\uffa5" +
    "\020\uffa5\021\uffa5\022\uffa5\023\uffa5\053\uffa5\054\uffa5\001" +
    "\002\000\036\004\023\005\017\006\035\007\034\010\024" +
    "\012\052\013\014\014\040\020\044\021\031\022\036\023" +
    "\030\053\ufffd\054\042\001\002\000\004\053\251\001\002" +
    "\000\040\004\uffa6\005\uffa6\006\uffa6\007\uffa6\010\uffa6\011" +
    "\uffa6\012\uffa6\013\uffa6\014\uffa6\020\uffa6\021\uffa6\022\uffa6" +
    "\023\uffa6\053\uffa6\054\uffa6\001\002\000\004\054\254\001" +
    "\002\000\004\050\uffdf\001\002\000\004\050\uffe0\001\002" +
    "\000\040\004\ufff5\005\ufff5\006\ufff5\007\ufff5\010\ufff5\011" +
    "\ufff5\012\ufff5\013\ufff5\014\ufff5\020\ufff5\021\ufff5\022\ufff5" +
    "\023\ufff5\053\ufff5\054\ufff5\001\002\000\016\016\074\017" +
    "\073\026\100\041\075\054\101\056\076\001\002\000\044" +
    "\025\121\026\117\027\123\030\106\031\114\032\112\033" +
    "\107\034\120\035\115\036\104\037\113\040\111\042\116" +
    "\043\122\044\110\045\105\051\260\001\002\000\004\046" +
    "\uffcf\001\002\000\010\020\044\021\031\051\uffda\001\002" +
    "\000\040\004\uffe1\005\uffe1\006\uffe1\007\uffe1\010\uffe1\011" +
    "\uffe1\012\uffe1\013\uffe1\014\uffe1\020\uffe1\021\uffe1\022\uffe1" +
    "\023\uffe1\053\uffe1\054\uffe1\001\002\000\006\047\274\051" +
    "\uffdb\001\002\000\004\051\uffde\001\002\000\004\054\266" +
    "\001\002\000\006\047\uffd9\051\uffd9\001\002\000\004\051" +
    "\270\001\002\000\004\052\271\001\002\000\036\004\023" +
    "\005\017\006\035\007\034\010\024\012\052\013\014\014" +
    "\040\020\044\021\031\022\036\023\030\053\ufffd\054\042" +
    "\001\002\000\004\053\273\001\002\000\040\004\uffdd\005" +
    "\uffdd\006\uffdd\007\uffdd\010\uffdd\011\uffdd\012\uffdd\013\uffdd" +
    "\014\uffdd\020\uffdd\021\uffdd\022\uffdd\023\uffdd\053\uffdd\054" +
    "\uffdd\001\002\000\006\020\044\021\031\001\002\000\004" +
    "\051\uffdc\001\002\000\006\047\277\051\uffd7\001\002\000" +
    "\006\020\044\021\031\001\002\000\004\051\uffd8\001\002" +
    "\000\016\016\uff98\017\uff98\026\uff98\041\uff98\054\uff98\056" +
    "\uff98\001\002\000\004\051\303\001\002\000\004\052\304" +
    "\001\002\000\036\004\uffff\005\uffff\006\uffff\007\uffff\010" +
    "\uffff\012\uffff\013\uffff\014\uffff\020\uffff\021\uffff\022\uffff" +
    "\023\uffff\053\uffff\054\uffff\001\002\000\036\004\023\005" +
    "\017\006\035\007\034\010\024\012\052\013\014\014\040" +
    "\020\044\021\031\022\036\023\030\053\ufffd\054\042\001" +
    "\002\000\004\053\307\001\002\000\040\004\uffa1\005\uffa1" +
    "\006\uffa1\007\uffa1\010\uffa1\011\uffa1\012\uffa1\013\uffa1\014" +
    "\uffa1\020\uffa1\021\uffa1\022\uffa1\023\uffa1\053\uffa1\054\uffa1" +
    "\001\002\000\040\004\ufff7\005\ufff7\006\ufff7\007\ufff7\010" +
    "\ufff7\011\ufff7\012\ufff7\013\ufff7\014\ufff7\020\ufff7\021\ufff7" +
    "\022\ufff7\023\ufff7\053\ufff7\054\ufff7\001\002\000\020\016" +
    "\074\017\073\026\100\041\075\051\uffd3\054\101\056\076" +
    "\001\002\000\004\051\321\001\002\000\006\047\316\051" +
    "\uffd0\001\002\000\046\025\121\026\117\027\123\030\106" +
    "\031\114\032\112\033\107\034\120\035\115\036\104\037" +
    "\113\040\111\042\116\043\122\044\110\045\105\047\uffd2" +
    "\051\uffd2\001\002\000\004\051\uffd4\001\002\000\016\016" +
    "\074\017\073\026\100\041\075\054\101\056\076\001\002" +
    "\000\006\047\316\051\uffd0\001\002\000\004\051\uffd1\001" +
    "\002\000\010\046\uffd5\047\uffd5\051\uffd5\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\317\000\004\002\004\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\056\010\001\001\000\054\003\047\004\042\005\012\012" +
    "\017\014\021\015\044\017\052\021\024\023\050\024\020" +
    "\027\026\030\025\031\011\032\045\034\032\037\046\042" +
    "\014\045\015\051\040\052\031\055\036\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\020" +
    "\261\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\034" +
    "\251\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\022\211\001\001\000\004\057\206\001\001" +
    "\000\004\041\205\001\001\000\002\001\001\000\004\030" +
    "\167\001\001\000\004\026\163\001\001\000\004\034\155" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\054\003\047\004\042\005\012" +
    "\012\017\014\021\015\151\016\150\021\024\023\050\024" +
    "\020\027\026\030\025\031\011\032\045\034\032\037\046" +
    "\042\014\045\015\051\040\052\031\055\036\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\056\055\001\001\000\010\011\057\032\056" +
    "\034\032\001\001\000\002\001\001\000\002\001\001\000" +
    "\010\053\063\054\062\063\061\001\001\000\004\041\076" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\033" +
    "\066\062\065\001\001\000\006\030\025\037\070\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\041\142\001\001\000\004\041\141\001\001\000" +
    "\004\041\140\001\001\000\004\041\137\001\001\000\004" +
    "\041\136\001\001\000\004\041\135\001\001\000\004\041" +
    "\134\001\001\000\004\041\133\001\001\000\004\041\132" +
    "\001\001\000\004\041\131\001\001\000\004\041\130\001" +
    "\001\000\004\041\127\001\001\000\004\041\126\001\001" +
    "\000\004\041\125\001\001\000\004\041\124\001\001\000" +
    "\004\041\123\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\054\003\047\004\042\005\012\012\017\014" +
    "\021\015\151\016\152\021\024\023\050\024\020\027\026" +
    "\030\025\031\011\032\045\034\032\037\046\042\014\045" +
    "\015\051\040\052\031\055\036\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\057\156\001" +
    "\001\000\010\030\025\036\160\037\157\001\001\000\002" +
    "\001\001\000\004\060\162\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\054\003\047\004\042" +
    "\005\012\012\017\014\021\015\044\017\165\021\024\023" +
    "\050\024\020\027\026\030\025\031\011\032\045\034\032" +
    "\037\046\042\014\045\015\051\040\052\031\055\036\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\006\035\174\046\175\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\041\200\001\001\000" +
    "\002\001\001\000\010\035\174\046\203\050\204\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\030\025\036\207\037\157\001\001" +
    "\000\004\060\210\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\056\214\001\001\000\004\056\216\001\001" +
    "\000\052\003\047\004\042\005\012\012\017\014\021\015" +
    "\215\021\024\023\050\024\020\027\026\030\025\031\011" +
    "\032\045\034\032\037\046\042\014\045\015\051\040\052" +
    "\031\055\036\001\001\000\002\001\001\000\054\003\047" +
    "\004\042\005\012\012\017\014\021\015\044\017\217\021" +
    "\024\023\050\024\020\027\026\030\025\031\011\032\045" +
    "\034\032\037\046\042\014\045\015\051\040\052\031\055" +
    "\036\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\031" +
    "\011\040\226\041\231\044\230\051\227\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\013\235" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\013" +
    "\237\001\001\000\002\001\001\000\006\053\241\063\061" +
    "\001\001\000\002\001\001\000\004\056\244\001\001\000" +
    "\004\056\246\001\001\000\052\003\047\004\042\005\012" +
    "\012\017\014\021\015\245\021\024\023\050\024\020\027" +
    "\026\030\025\031\011\032\045\034\032\037\046\042\014" +
    "\045\015\051\040\052\031\055\036\001\001\000\002\001" +
    "\001\000\054\003\047\004\042\005\012\012\017\014\021" +
    "\015\044\017\247\021\024\023\050\024\020\027\026\030" +
    "\025\031\011\032\045\034\032\037\046\042\014\045\015" +
    "\051\040\052\031\055\036\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\041\256\001\001\000" +
    "\002\001\001\000\002\001\001\000\010\025\262\034\264" +
    "\043\263\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\061\266\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\054\003\047\004" +
    "\042\005\012\012\017\014\021\015\044\017\271\021\024" +
    "\023\050\024\020\027\026\030\025\031\011\032\045\034" +
    "\032\037\046\042\014\045\015\051\040\052\031\055\036" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\007" +
    "\274\025\275\034\264\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\007\277\025\275\034\264\001\001\000" +
    "\002\001\001\000\006\053\301\063\061\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\056\304\001\001\000" +
    "\054\003\047\004\042\005\012\012\017\014\021\015\044" +
    "\017\305\021\024\023\050\024\020\027\026\030\025\031" +
    "\011\032\045\034\032\037\046\042\014\045\015\051\040" +
    "\052\031\055\036\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\010\010\311\041\313\047\312" +
    "\001\001\000\002\001\001\000\004\006\314\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\041\313\047\316" +
    "\001\001\000\004\006\317\001\001\000\002\001\001\000" +
    "\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



//Symbol table to check semantics of the code
private SymbolTable st = new SymbolTable();

private int errorsFound=0;
private ArrayList<String> errors = new ArrayList<String>();

//variable to know in which state we are, we use it in ASSIGNATION to know if we are declaring and assigning or just assigning
public String currentState= "";

//upperID to use in function and procedure declaration.
public String upperID = null;

//STACK to transfer information between productions
public Stack <String> ids = new Stack<String>();
public Stack <String> funcIDS = new Stack<String>();
public Stack <Integer> length = new Stack<Integer>();


CodeGenerator c = new CodeGenerator(st);
public CodeGenerator get3AC(){
    return c;
}

public void print3AddressCode(PrintStream out){
    c.print3AddressCode(out);
}
public void assemblyCode(PrintStream out)throws Exception{
    AssemblyGenerator.generateAssembly(out,c.getCode(),c.getVt(),c.getProcedures(),c.getPl());
}


public void print3AddressVars(PrintStream out){
    c.print3AddressVars(out);
}



    //errorSemantic, if it's true we will stop generating code and we will enter panic mode
    private boolean errorSemantic = false;


    /**********************************************************************
     * Override methods to manage errors                                  *
     **********************************************************************/

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
        report_error("Unrecovered syntax error", cur_token);
        done_parsing();
    }

    @Override
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }

    @Override
     public void report_error(String message, Object info){
            this.errorsFound++;
            StringBuilder msg = new StringBuilder("ERROR");
            if(info instanceof Symbol){
                ComplexSymbol token = (ComplexSymbol) this.cur_token;
                Location l = token.getLeft();

                if(l != null){
                    msg.append(" row: " + l.getLine() + ", col: " + l.getColumn());
                }
            }
            msg.append("-> " + message);
            errors.add(msg.toString());
            System.err.println(msg);
        }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error("Unrecoverable error: ("+message+")", info);
        done_parsing();
    }

    public void printErrors(PrintStream out){
            String fmt = "%s";
            for (int i = 0; i <errors.size();i++){
               out.println(String.format(fmt,errors.get(i)));
            }
    }

    public int getFoundErrors(){
        return this.errorsFound;
    }



/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$Parser$actions {
  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action_part00000000(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= PROGRAM EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // PROGRAM ::= function main openb M0 BLOCK closeb 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                                                //if block is true we have a return clause in the main so we throw an error
                                                if(!b.equals("")){
                                                    var serr = new SymbolError();
                                                    report_error("Return out of function declaration",serr);
                                                }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // M0 ::= 
            {
              Object RESULT =null;
		st.enterBlock();
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M0",44, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // BLOCK ::= LINE LINEP 
            {
              String RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String l = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int lpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String lp = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 st.exitBlock();
                                                String s;
                                                        if(l.equals("")&&!lp.equals("")){
                                                            RESULT = lp;
                                                        }else
                                                        if(!l.equals("")&&lp.equals("")){
                                                             RESULT = l;
                                                         }else
                                                        if(l.equals(lp)){
                                                            RESULT = l;
                                                            //if we get here line and linep are different but both are different of "" so we have in the same block 2 return statement with different types
                                                        }else{
                                                        var serr = new SymbolError();
                                                        report_fatal_error("Two return statements with different types",serr);
                                                        }
                                                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // BLOCK ::= 
            {
              String RESULT =null;
		
                                                    RESULT = "";
                                                    st.exitBlock();
                                                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOCK",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // LINEP ::= LINE LINEP 
            {
              String RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String l = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int lpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String lp = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
        String s;
        if(l.equals("")&&!lp.equals("")){
            RESULT = lp;
        }else
        if(!l.equals("")&&lp.equals("")){
             RESULT = l;
         }else
        if(l.equals(lp)){
            RESULT = l;
            //if we get here line and linep are different but both are different of "" so we have in the same block 2 return statement with different types
        }else{
            var serr = new SymbolError();
            report_error("Two return statements with different types",serr);
        }


              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINEP",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // LINEP ::= 
            {
              String RESULT =null;
		RESULT = "";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINEP",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // LINE ::= DECLARATION semicolon 
            {
              String RESULT =null;
		RESULT =""; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINE",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // LINE ::= ASSIGNATION semicolon 
            {
              String RESULT =null;
		RESULT ="";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINE",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // LINE ::= PRINT semicolon 
            {
              String RESULT =null;
		RESULT ="";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINE",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // LINE ::= INPUT semicolon 
            {
              String RESULT =null;
		RESULT =""; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINE",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // LINE ::= FUNCALL semicolon 
            {
              String RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolFUNCALL f = (SymbolFUNCALL)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                                                    RESULT ="";
                                                    c.call(f.getID());
                                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINE",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // LINE ::= RETURN semicolon 
            {
              String RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String r = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT =r; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINE",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // LINE ::= CONDITIONAL 
            {
              String RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT =c; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINE",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // LINE ::= FUNPROCDECLARATION 
            {
              String RESULT =null;
		RESULT =""; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINE",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // LINE ::= TUPLE 
            {
              String RESULT =null;
		RESULT =""; 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LINE",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // M2 ::= 
            {
              Object RESULT =null;
		currentState = "DECLARATION";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M2",45, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // M3 ::= 
            {
              Object RESULT =null;
		currentState = "";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M3",46, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // ID ::= id 
            {
              String RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		ids.push(id);
            RESULT = id;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ID",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // DECLARATION ::= constt TYPE M2 DECLARATIONP M3 
            {
              Integer RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		SymbolTYPE type = (SymbolTYPE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int declpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int declpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolDECLARATIONP declp = (SymbolDECLARATIONP)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                        var serr = new SymbolError();
                        if(declp.getType() == null){
                            report_error("Declaring constant without value",serr);
                            errorSemantic = true;
                        }else
                        if(declp.getType().equals("")){
                            report_error("Declaring constant using tuple call",serr);
                            errorSemantic = true;
                        }else{
                            Description dType = st.consult(declp.getType());
                            String typ  = declp.getType();
                            String id = declp.getID();
                            int value =  declp.getValue();
                            if(!type.getType().equals(typ)){
                                report_fatal_error("Types do not match",serr);
                                errorSemantic = true;
                            }
                            if(dType.getMin() > value || dType.getMax() < value){
                                report_fatal_error("Value of "+id+" out of range",serr);
                                errorSemantic = true;
                            }
                            st.put(id, new Description(id, st.getLevel(),Description.dConstant , value,typ));
                            int val = c.declare(id,typ,false);
                            c.assignation(declp.getR(),c.declare(id,typ,false));
                            RESULT = st.consult(declp.getID()).gettd();
                        }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLARATION",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // DECLARATION ::= TYPE M2 DECLARATIONP M3 
            {
              Integer RESULT =null;
		int typeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		SymbolTYPE type = (SymbolTYPE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int declpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int declpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolDECLARATIONP declp = (SymbolDECLARATIONP)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                             var serr = new SymbolError();
                             //only declaration (no type check)
                             if(declp.getType() == null && type.getType().equals(Description.TypeTuple)){
                                if(!type.getType().equals(Description.TypeTuple)){
                                    st.put(declp.getID(), new Description(declp.getID(),Description.dVariable,type.getType()));
                                    int val = c.declare(declp.getID(),type.getType(),false);
                                    c.assignationVal(0,val);
                                    RESULT = -1;
                                }
                             //if type is not null it is a declaration + assignation
                             }else{
                                 Description dType = st.consult(declp.getType());
                                 String typ = declp.getType();
                                 String id = declp.getID();
                                 //if declp.getType is null it means that it is a variable without assignation so
                                 //we don't have to check if the types match
                                 if(typ != null && !type.getType().equals(typ)){
                                     report_fatal_error("Types do not match",serr);
                                     errorSemantic = true;
                                 }else{
                                    st.put(id, new Description(id,Description.dVariable,type.getType()));
                                    int val = c.declare(id,typ,false);
                                    //if it is a function we declare a call + assignation
                                    if(declp.function() != null)
                                        c.call(st.consult(id).getIndexVT(),declp.function());
                                    else
                                    //if typ is null we have a declaration without assigation so we assigante the value 0
                                    if(typ == null)
                                        c.assignationVal(0,val);
                                    else
                                        c.assignation(declp.getR(),val);
                                    RESULT = st.consult(declp.getID()).gettd();
                                 }
                                 }


                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLARATION",24, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // DECLARATIONP ::= id 
            {
              SymbolDECLARATIONP RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String v = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = new SymbolDECLARATIONP(v);
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLARATIONP",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // DECLARATIONP ::= ASSIGNATION 
            {
              SymbolDECLARATIONP RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolASSIGNATION v = (SymbolASSIGNATION)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		 RESULT = new SymbolDECLARATIONP(v.getID(),v.getType(),v.getValue(),v.getR(),v.function());
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLARATIONP",28, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // ASSIGNATION ::= ID equal ASSIGNATIONP 
            {
              SymbolASSIGNATION RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String v = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int aspleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int aspright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolASSIGNATIONP asp = (SymbolASSIGNATIONP)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
        var serr = new SymbolError();
        ids.pop();
        if(!currentState.equals("DECLARATION")){
        String TYPE = st.getType(v);
        //if TYPE is null means that the id is not declared
        if(TYPE == null){
            report_error("Variable "+v+" not declared",serr);
            errorSemantic = true;
        //if it is declared but it is not the same type as asp it means we have a type error
        }
        if(asp.getType().equals("")){
            //it's checked in executing time

        }else
        if(!TYPE.equals(asp.getType())){
            report_fatal_error("Type doesn't match for id: "+v,serr);
            errorSemantic = true;
        }else
        if(st.consult(v).gettd() == Description.dConstant){
            report_error("Trying to edit a constant: "+v,serr);
            errorSemantic = true;
        }else
        if(asp.isFunction()){
            c.call(st.consult(v).getIndexVT(),asp.getID());
        }else{
        c.assignation(asp.getR(),st.consult(v).getIndexVT());
        RESULT = new SymbolASSIGNATION(v,asp.getType(),asp.getValue(),asp.getR(),asp.getID());

        }

        }
        //if the currentState is not ASSIGNATION it means it is declaration and we need to send the information
        else
            RESULT = new SymbolASSIGNATION(v,asp.getType(),asp.getValue(),asp.getR(),asp.getID());

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASSIGNATION",29, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // ASSIGNATIONP ::= E 
            {
              SymbolASSIGNATIONP RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE e = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = new SymbolASSIGNATIONP(null,e.getType(),e.getValue(),e.getR());
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASSIGNATIONP",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // ASSIGNATIONP ::= TUPLECALL 
            {
              SymbolASSIGNATIONP RESULT =null;
		int tupleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tupright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolTUPLECALL tup = (SymbolTUPLECALL)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = new SymbolASSIGNATIONP(null,tup.getType(),0,tup.getR());
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASSIGNATIONP",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // ASSIGNATIONP ::= FUNCALL 
            {
              SymbolASSIGNATIONP RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolFUNCALL f = (SymbolFUNCALL)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    var serr = new SymbolError();
                    Description d = st.consult(f.getID());
                    if(d == null){
                        report_error("ID not declared (not in st)",serr);
                    }
                    if(d.gettd() != Description.dFunction){
                        report_fatal_error("ID is not a function",serr);
                    }
                    RESULT = new SymbolASSIGNATIONP(d.getType(),f.getID());
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASSIGNATIONP",30, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // TYPE ::= integer 
            {
              SymbolTYPE RESULT =null;
		 RESULT = new SymbolTYPE(SymbolTYPE.TypeInt); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TYPE",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // TYPE ::= bool 
            {
              SymbolTYPE RESULT =null;
		RESULT = new SymbolTYPE(SymbolTYPE.TypeBool);  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TYPE",26, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // TYP ::= integer 
            {
              SymbolTYPE RESULT =null;
		 RESULT = new SymbolTYPE(SymbolTYPE.TypeInt); 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TYP",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // TYP ::= bool 
            {
              SymbolTYPE RESULT =null;
		RESULT = new SymbolTYPE(SymbolTYPE.TypeBool);  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TYP",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // TYP ::= tuple 
            {
              SymbolTYPE RESULT =null;
		RESULT = new SymbolTYPE(SymbolTYPE.TypeTuple);  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TYP",27, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // FUNPROCDECLARATION ::= FUNPROC BODY 
            {
              Object RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolFUNPROC f = (SymbolFUNPROC)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                upperID = null;
                var serr = new SymbolError();
                if(f.gettd() == Description.dFunction){
                    if(b.isEmpty()){
                        report_error("Function without return statement",serr);
                        errorSemantic = true;
                    }
                    else {
                    Description d = st.consult(f.getID());
                    //if b return is different
                    if(d == null || !d.getType().equals(b)){
                        report_error("Return statement or statements type don't match ",serr);
                        errorSemantic = true;
                    }
                    }
                    }else{
                        if(!b.isEmpty()){
                            report_error("Return in procedure",serr);
                            errorSemantic = true;
                        }
                    }


    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNPROCDECLARATION",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // FUNPROC ::= function TYPE id 
            {
              SymbolFUNPROC RESULT =null;
		int TYPEleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int TYPEright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolTYPE TYPE = (SymbolTYPE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String v = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                var serr = new SymbolError();
                if(st.getLevel()!= 1){
                     report_fatal_error("Trying to declare a function out of base level",serr);
                     errorSemantic = true;
                }
                else
                if(st.existsFunction(v)){
                    report_fatal_error("Function "+v+" already exists",serr);
                    errorSemantic = true;
                }else{
                    upperID = v;
                    st.put(v,new Description(v,Description.dFunction,TYPE.getType()));
                    RESULT = new SymbolFUNPROC(Description.dFunction,v);
                }
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNPROC",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // FUNPROC ::= function id 
            {
              SymbolFUNPROC RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String v = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                var serr = new SymbolError();
                if(st.getLevel()!= 1){
                     report_fatal_error("Trying to declare a function out of base level",serr);
                     errorSemantic = true;
                }
                else
                if(st.existsFunction(v)){
                     report_fatal_error("Procedure "+v+" already exists",serr);
                    errorSemantic = true;
                }else{
                    upperID = v;
                    st.put(v,new Description(v,Description.dProcedure,""));
                    RESULT = new SymbolFUNPROC(Description.dProcedure,v);
                }

    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNPROC",32, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // M1 ::= 
            {
              Integer RESULT =null;
		
            int goTo = c.pmb(upperID);
            RESULT = goTo;
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M1",47, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // BODY ::= openp PARAMETERS M1 closep openb BLOCK closeb 
            {
              String RESULT =null;
		int goToleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int goToright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Integer goTo = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
            if(!errorSemantic) c.rtn();
            c.label(goTo);
             RESULT = b;
             
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BODY",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // PARAMETERS ::= PARAMETER comma PARAMETERP 
            {
              SymbolPARAMETERS RESULT =null;
		
            st.enterBlock();
            st.setParams(upperID);
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETERS",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // PARAMETERS ::= PARAMETER 
            {
              SymbolPARAMETERS RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String p = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
            st.enterBlock();
            st.put(p,st.getParam(upperID,1));
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETERS",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // PARAMETERS ::= 
            {
              SymbolPARAMETERS RESULT =null;
		
            st.enterBlock();

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETERS",33, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // PARAMETER ::= TYPE id 
            {
              String RESULT =null;
		int TYPEleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int TYPEright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolTYPE TYPE = (SymbolTYPE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String v = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
            int i = c.functionParameter(TYPE.getType());
            st.addParameter(upperID,v,new Description(v,Description.dArg,TYPE.getType(),i));
            RESULT = v;


              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETER",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // PARAMETERP ::= PARAMETER comma PARAMETERP 
            {
              Object RESULT =null;
		  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETERP",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // PARAMETERP ::= PARAMETER 
            {
              Object RESULT =null;
		 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMETERP",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // IDF ::= id 
            {
              String RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                var serr = new SymbolError();
                Description d = st.consult(id);
                if(d == null){
                    report_fatal_error("Function doesn't exist",serr);
                }else
                if(d.gettd() != Description.dFunction && d.gettd() != Description.dProcedure){
                    report_fatal_error(id+ " is not a function or procedure ",serr);
                }else{
                    funcIDS.push(id);
                    length.push(st.getFuncSize(id));
                    RESULT = id;
                }
                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IDF",23, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // FUNCALL ::= IDF openp PARAMS closep 
            {
              SymbolFUNCALL RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		                           var serr = new SymbolError();
                             if(id.equals(upperID)){
                                report_error("Recursion is not allowed",serr);
                             }
                             //empty the stacks (IDF)
                             funcIDS.pop();
                             int n = length.pop();
                             if(n !=0){
                                 report_error("More parameters needed",serr);
                             }
                            RESULT = new SymbolFUNCALL(id);
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FUNCALL",39, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // PARAMS ::= PARAM PARAMP 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolPARAM p = (SymbolPARAM)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                                                                       var serr = new SymbolError();
                                                                       int len = length.pop();
                                                                       if(len <= 0) {
                                                                           report_fatal_error("Parameters calling function or procedure",serr);
                                                                           errorSemantic = true;
                                                                       }else{
                                                                           Description d = st.getParam(funcIDS.peek(),len);
                                                                           if(!d.getType().equals(p.getType())){
                                                                               report_error("Type of parameter",serr);
                                                                           }
                                                                           len--;
                                                                           length.push(len);
                                                                               }
                                                                       
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMS",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // PARAMS ::= 
            {
              Object RESULT =null;
		
        if(length.peek()!=0){
        var serr = new SymbolError();
        report_error("the function has more parameters",serr);
        }
            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMS",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // PARAM ::= E 
            {
              SymbolPARAM RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE e = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = new SymbolPARAM(e.getType());
                                            c.param(e.getR());
                                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAM",37, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // PARAMP ::= comma PARAM PARAMP 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolPARAM p = (SymbolPARAM)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                                             var serr = new SymbolError();
                                             int len = length.pop();
                                             if(len <= 0) {
                                                 report_fatal_error("Parameters calling function or procedure",serr);
                                                 errorSemantic = true;
                                             }else{
                                                 Description d = st.getParam(funcIDS.peek(),len);
                                                 if(!d.getType().equals(p.getType())){
                                                 }
                                                 len--;
                                                 length.push(len);
                                                     }
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMP",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // PARAMP ::= 
            {
              Object RESULT =null;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PARAMP",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // PRINT ::= PRINTP openp E closep 
            {
              Object RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Boolean b = (Boolean)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolE e = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                                if(e.getType().equals(Description.TypeTuple)){
                                    var serr = new SymbolError();
                                    report_fatal_error("Parameters calling function or procedure",serr);
                                    errorSemantic = true;
                                }
                                if(b) c.print(e.getR());
                                else  c.println(e.getR());

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PRINT",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // PRINTP ::= print 
            {
              Boolean RESULT =null;
		RESULT = true;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PRINTP",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // PRINTP ::= println 
            {
              Boolean RESULT =null;
		RESULT = false;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PRINTP",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // TUPLE ::= tuple ID openb TUPLEP 
            {
              SymbolTUPLE RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolTUPLEP tp = (SymbolTUPLEP)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                    Description d = st.consult(id);
                    d.setValue(tp.getValue());
                    RESULT = new SymbolTUPLE(Description.TypeTuple);
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TUPLE",35, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // TUPLEP ::= TYP id equal E semicolon TUPLEPP 
            {
              SymbolTUPLEP RESULT =null;
		int TYPEleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int TYPEright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		SymbolTYPE TYPE = (SymbolTYPE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE e = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int tppleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tppright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolTUPLEPP tpp = (SymbolTUPLEPP)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
            //if TYPE is not int it's an error
            if(!TYPE.getType().equals(e.getType())){
                var serr = new SymbolError();
                report_fatal_error("Parameters calling function or procedure",serr);
                errorSemantic = true;
            }
            //if we have to insert to the te it means that this is a tuple into a tuple so we have to add the field to the last tuple in the te
            if(!errorSemantic && TYPE.getType().equals(Description.TypeTuple)){
                st.addField(ids.peek(),id,new Description(id,Description.dArg,TYPE.getType(),e.getID(),e.getR()));
                RESULT = new SymbolTUPLEP(st.consult(e.getID()).getValue() + tpp.getValue());
            }else{
                if(!errorSemantic){
                    st.addField(ids.peek(),id,new Description(id,Description.dArg,TYPE.getType(),e.getR()));
                    RESULT = new SymbolTUPLEP(SymbolTable.getSizeType(e.getType()) + tpp.getValue());
                }
            }



    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TUPLEP",36, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // TUPLEPP ::= TUPLEP 
            {
              SymbolTUPLEPP RESULT =null;
		int tpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolTUPLEP tp = (SymbolTUPLEP)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
            RESULT = new SymbolTUPLEPP(tp.getValue());
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TUPLEPP",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // TUPLEPP ::= closeb 
            {
              SymbolTUPLEPP RESULT =null;
		
            Description d = st.consult(ids.peek());
            if(d != null){
                var serr = new SymbolError();
                report_fatal_error("Symbol tuple already declared or exists",serr);
                errorSemantic = true;
            }else{
            st.put(ids.peek(), new Description(ids.peek(), Description.dConstant, Description.TypeTuple));
            RESULT = new SymbolTUPLEPP(0);
            }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TUPLEPP",38, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // TUPLECALL ::= id dot id TCP 
            {
              SymbolTUPLECALL RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		String v1 = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String v2 = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int tcpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tcpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolTCP tcp = (SymbolTCP)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            SymbolError serr = new SymbolError();
                            Stack<String> calls = tcp.getCalls();
                            if(!errorSemantic){
                                Description  pre = st.checkField(v1,v2);
                                if(Objects.isNull(pre)){
                                    report_fatal_error("calling tuple error",serr);
                                    done_parsing();
                                }else{
                                    Description aux = null;
                                    while(!calls.isEmpty()){
                                        if(!pre.getType().equals(Description.TypeTuple)){
                                            errorSemantic = true;
                                            calls.clear();
                                            report_fatal_error("incorrect use of tuple call",serr);
                                        }
                                        else{
                                            aux = st.consult(pre.getTupleRef());
                                            pre = st.checkField(aux.getID(),calls.pop());
                                        }
                                    }
                                }
                                if(Objects.isNull(pre)){
                                   report_fatal_error("calling tuple error",serr);
                                   done_parsing();
                                }
                                else{
                                    RESULT = new SymbolTUPLECALL(pre.getType(),pre.getIndexVT());

                                }
                            }

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TUPLECALL",34, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // TCP ::= dot id TCP 
            {
              SymbolTCP RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int tcpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tcpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolTCP tcp = (SymbolTCP)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = new SymbolTCP(tcp.getCalls(),id);
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TCP",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // TCP ::= 
            {
              SymbolTCP RESULT =null;
		RESULT = new SymbolTCP();
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("TCP",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // INPUT ::= input openp id closep 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                                                var serr = new SymbolError();
                                                if(st.consult(id) == null){
                                                    report_fatal_error(id+" id not declared ",serr);
                                                    errorSemantic = true;
                                                }else
                                                if(st.consult(id).gettd() == Description.dFunction){
                                                    report_error("Semantic id is function ",serr);
                                                }
                                                else
                                                if(st.consult(id).gettd() == Description.dConstant){
                                                    report_error("input can't be constant",serr);
                                                 }else
                                                 if(!st.consult(id).getType().equals(Description.TypeInt))
                                                    report_error("Input must be integer ",serr);
                                                 else
                                                    c.input(st.consult(id).getIndexVT());

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INPUT",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // RETURN ::= returnt E 
            {
              String RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE e = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                        RESULT = e.getType();
                                        c.rtn(e.getR());
                                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("RETURN",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // E ::= E sumop E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        var serr = new SymbolError();
                        if(!v1.getType().equals(v2.getType())){
                             report_fatal_error("Types do not match",serr);
                        }else
                        if(!v1.getType().equals(Description.TypeInt)){
                            report_fatal_error("Sum must use integer",serr);
                        }else
                        if(v2.getNegative()){
                            report_fatal_error("Two signs in a row",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.arithmetic("add",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeInt,v1.getNegative());
                     RESULT.setR(destination);
                    }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // E ::= E minop E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        var serr = new SymbolError();
                        if(!v1.getType().equals(v2.getType())){
                             report_fatal_error("Types do not match",serr);
                        }else
                        if(!v1.getType().equals(Description.TypeInt)){
                            report_fatal_error("Rest must use integer",serr);
                        }else
                        if(v2.getNegative()){
                            report_fatal_error("Two signs in a row",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.arithmetic("sub",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeInt,v1.getNegative());
                     RESULT.setR(destination);
                    }

                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // E ::= E mulop E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        var serr = new SymbolError();
                        if(!v1.getType().equals(v2.getType())){
                             report_fatal_error("Types do not match",serr);
                        }else
                        if(!v1.getType().equals(Description.TypeInt)){
                            report_fatal_error("Multiplication must use integer",serr);
                        }else
                        if(v2.getNegative()){
                            report_fatal_error("Two signs in a row",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.arithmetic("prod",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeInt,v1.getNegative());
                     RESULT.setR(destination);
                    }
                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // E ::= E divop E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        var serr = new SymbolError();
                        if(!v1.getType().equals(v2.getType())){
                             report_fatal_error("Types do not match",serr);
                        }else
                        if(!v1.getType().equals(Description.TypeInt)){
                            report_fatal_error("Division must use integer",serr);
                        }else
                        if(v2.getNegative()){
                            report_fatal_error("Two signs in a row",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.arithmetic("div",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeInt,v1.getNegative());
                     RESULT.setR(destination);
                    }

                    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // E ::= E and E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())){
                         report_fatal_error("Types do not match",serr);
                    }else
                    if(!v1.getType().equals(Description.TypeBool)){
                        report_fatal_error("AND must use boolean",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.logic("and",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // E ::= E or E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())){
                         report_fatal_error("Types do not match",serr);
                    }else
                    if(!v1.getType().equals(Description.TypeBool)){
                         report_fatal_error("OR must use boolean",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.logic("or",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // E ::= E xor E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())){
                         report_fatal_error("Types do not match",serr);
                    }else
                    if(!v1.getType().equals(Description.TypeBool)){
                        report_fatal_error("XOR must use boolean",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.logic("xor",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // E ::= E nand E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())){
                         report_fatal_error("Types do not match",serr);
                    }else
                    if(!v1.getType().equals(Description.TypeBool)){
                        report_fatal_error("NAND must use boolean",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.logic("nand",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // E ::= E nor E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())){
                        report_fatal_error("Types do not match",serr);
                    }else
                    if(!v1.getType().equals(Description.TypeBool)){
                        report_fatal_error("NOR must use boolean",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.logic("nor",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // E ::= E xnor E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())){
                        report_fatal_error("Types do not match",serr);
                    }else
                    if(!v1.getType().equals(Description.TypeBool)){
                        report_fatal_error("XNOR must use boolean",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.logic("xnor",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // E ::= E equalrel E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType()) || v1.getType().equals(Description.TypeTuple)){
                          report_fatal_error("Types do not match",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.relational("EQ",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // E ::= E notequalrel E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())|| v1.getType().equals(Description.TypeTuple)){
                         report_fatal_error("Types do not match",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.relational("NE",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // E ::= E greaterrel E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())){
                         report_fatal_error("Types do not match",serr);
                    }else
                    if(!v1.getType().equals(Description.TypeInt)){
                        report_fatal_error("> must use integer",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.relational("GT",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // E ::= E lessrel E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())){
                         report_fatal_error("Types do not match",serr);
                    }else
                    if(!v1.getType().equals(Description.TypeInt)){
                        report_fatal_error("< must use integer",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.relational("LT",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // E ::= E greatereqrel E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())){
                         report_fatal_error("Types do not match",serr);
                    }else
                    if(!v1.getType().equals(Description.TypeInt)){
                        report_fatal_error(">= must use integer",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.relational("GE",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,false);
                     RESULT.setR(destination);
                    }
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // E ::= E lesseqrel E 
            {
              SymbolE RESULT =null;
		int v1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int v1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		SymbolE v1 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int v2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int v2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE v2 = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                     var serr = new SymbolError();
                     if(!v1.getType().equals(v2.getType())){
                        report_fatal_error("Types do not match",serr);
                    }else
                    if(!v1.getType().equals(Description.TypeInt)){
                        report_fatal_error("<= must use integer",serr);
                    }else{
                     int destination = c.declare(c.nextVar(),Description.TypeInt,true);
                     c.relational("LE",v1.getR(),v2.getR(),destination);
                     RESULT = new SymbolE(Description.TypeBool,v1.getNegative());
                     RESULT.setR(destination);
                    }

        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // E ::= id 
            {
              SymbolE RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                                var serr = new SymbolError();
                                                if(st.consult(id) == null){
                                                    report_fatal_error(id+" id not declared ",serr);
                                                    errorSemantic = true;
                                                }else
                                                if(st.consult(id).gettd() == Description.dFunction){
                                                    report_fatal_error("id is function ",serr);
                                                }else
                                                if(st.consult(id).getType().equals(Description.TypeTuple)){
                                                    RESULT = new SymbolE(id,Description.TypeTuple);

                                                }
                                                else
                                                if(st.consult(id).gettd() == Description.dConstant){
                                                    int index = st.consult(id).getIndexVT();
                                                    String var = c.nextVar();
                                                    int destination = c.declare(var,Description.TypeInt,true);
                                                    c.assignation(index,destination);
                                                    RESULT = new SymbolE(st.consult(id).getType(),false,st.consult(id).getValue(),destination);
                                                 }else{
                                                     int index = st.consult(id).getIndexVT();
                                                     int destination = c.declare(c.nextVar(),st.consult(id).getType(),true);
                                                     c.assignation(index,destination);
                                                     RESULT = new SymbolE(st.consult(id).getType(),false);
                                                     RESULT.setR(destination);
                                                 }
                                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // E ::= minop id 
            {
              SymbolE RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                                 var serr = new SymbolError();
                                                 if(st.consult(id) == null){
                                                     report_fatal_error(id+" id not declared ",serr);
                                                     errorSemantic = true;
                                                 }else
                                                 if(st.consult(id).gettd() == Description.dFunction){
                                                     report_fatal_error(" id is function",serr);
                                                 }else
                                                 if(!st.consult(id).getType().equals(Description.TypeInt)){
                                                    report_fatal_error("Types do not match",serr);
                                                 }else
                                                 if(st.consult(id).gettd() == Description.dConstant){
                                                    int index = st.consult(id).getIndexVT();
                                                    String var = c.nextVar();
                                                    int destination = c.declare(var,Description.TypeInt,true);
                                                    //result is: res = -id which is the same as 0-id.
                                                   c.arithmetic("sub",0,index,destination);
                                                    RESULT = new SymbolE(Description.TypeInt,true,-st.consult(id).getValue(),destination);
                                                 }else{
                                                     int index = st.consult(id).getIndexVT();
                                                     String var = c.nextVar();
                                                     int destination = c.declare(var,Description.TypeInt,true);
                                                     c.arithmetic("sub",-1,index,destination);
                                                     RESULT = new SymbolE(Description.TypeInt,true);
                                                     RESULT.setR(destination);
                                                 }

                                                 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // E ::= number 
            {
              SymbolE RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		int n = (int)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                        String var = c.nextVar();
                        int destination = c.declare(var,Description.TypeInt,true);
                        c.assignationVal(n,destination);
                        RESULT = new SymbolE(Description.TypeInt,false,n,destination);
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // E ::= minop number 
            {
              SymbolE RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		int n = (int)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		

                        String var = c.nextVar();
                        int destination = c.declare(var,Description.TypeInt,true);
                        c.assignationVal(-n,destination);
                        RESULT = new SymbolE(Description.TypeInt,true,-n,destination);
                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // E ::= truet 
            {
              SymbolE RESULT =null;
		

                                String var = c.nextVar();
                                int destination = c.declare(var,Description.TypeBool,true);
                                c.assignationVal(-1,destination);
                                RESULT = new SymbolE(Description.TypeBool,false,-1,destination);
                                                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // E ::= falset 
            {
              SymbolE RESULT =null;
		

                                String var = c.nextVar();
                                int destination = c.declare(var,Description.TypeBool,true);
                                c.assignationVal(0,destination);
                                RESULT = new SymbolE(Description.TypeBool,false,0,destination);
                                                                
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // E ::= not id 
            {
              SymbolE RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                                  var serr = new SymbolError();
                                                  if(st.consult(id) == null){
                                                      report_fatal_error(id+" id not declared ",serr);
                                                      errorSemantic = true;
                                                  }else
                                                  if(st.consult(id).gettd() == Description.dFunction){
                                                      report_fatal_error("id is function ",serr);
                                                  }else
                                                  if(!st.consult(id).getType().equals(Description.TypeBool)){
                                                     report_fatal_error("Types do not match ",serr);
                                                  }else
                                                  if(st.consult(id).gettd() == Description.dConstant){
                                                    int val = st.consult(id).getValue();
                                                    //if it is a constant we apply the not operation
                                                    if(val == 0)
                                                        val = -1;
                                                    else
                                                        val = 0;
                                                    int index = st.consult(id).getIndexVT();
                                                    int destination = c.declare(c.nextVar(),Description.TypeBool,true);
                                                    c.logic("not",index,0,destination);
                                                    RESULT = new SymbolE(Description.TypeBool,false,val,destination);
                                                    }
                                                   else{
                                                       int index = st.consult(id).getIndexVT();
                                                       int destination = c.declare(c.nextVar(),Description.TypeBool,true);
                                                       c.logic("not",index,0,destination);
                                                       RESULT = new SymbolE(Description.TypeBool,false);
                                                       RESULT.setR(destination);

                                                   }
                                                  
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // E ::= not truet 
            {
              SymbolE RESULT =null;
		
                                int destination = c.declare(c.nextVar(),Description.TypeBool,true);
                                c.assignationVal(0,destination);
                                RESULT = new SymbolE(Description.TypeBool,false,0,destination);
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // E ::= not falset 
            {
              SymbolE RESULT =null;
		
                                int destination = c.declare(c.nextVar(),Description.TypeBool,true);
                                c.assignationVal(-1,destination);
                                RESULT = new SymbolE(Description.TypeBool,false,-1,destination);
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("E",31, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // CONDITIONAL ::= IF 
            {
              String RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String i = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = i;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDITIONAL",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // CONDITIONAL ::= WHILE 
            {
              String RESULT =null;
		int wleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int wright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String w = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = w;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDITIONAL",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // CONDITIONAL ::= FOR 
            {
              String RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String f = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = f;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDITIONAL",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // IF ::= IFP ELSE 
            {
              String RESULT =null;
		int ifpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ifpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolIFP ifp = (SymbolIFP)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int elsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int elsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String els = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                            String l = ifp.getLine();
                            String lp = els;
                            if(l.equals("")&&!lp.equals("")){
                                RESULT = lp;
                            }else
                            if(!l.equals("")&&lp.equals("")){
                                 RESULT = l;
                             }else
                            if(l.equals(lp)){
                                RESULT = l;
                                //if we get here line and linep are different but both are different of "" so we have in the same block 2 return statement with different types
                            }else{
                            var serr = new SymbolError();
                            report_error("Two return statements with different types",serr);
                            }
                            //regardless of whether there is else or not we put the final tag
                            c.label(ifp.getEnd());
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IF",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // IFP ::= ift openp CONDITION closep openb M0 BLOCK closeb 
            {
              SymbolIFP RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		SymbolCONDITION cond = (SymbolCONDITION)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		                                              //if we execute the if, we jump to the end of the if
                                                    int end = c.nextLabel();
                                                    c.goTo(end);
                                                    //pre else label, if condition is false we jump here (execute else)
                                                    c.label(cond.getEnd());
                                                    RESULT = new SymbolIFP(end,b);
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IFP",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // IFP ::= ift openp CONDITION closep M0 LINE 
            {
              SymbolIFP RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		SymbolCONDITION cond = (SymbolCONDITION)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String l = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                                    st.exitBlock();
                                                    int end = c.nextLabel();
                                                    c.goTo(end);
                                                    c.label(cond.getEnd());
                                                    RESULT = new SymbolIFP(end,l);
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IFP",40, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // ELSE ::= elset openb M0 BLOCK closeb 
            {
              String RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = b;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ELSE",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // ELSE ::= elset M0 LINE 
            {
              String RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String l = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                st.exitBlock();
                                RESULT = l;
    
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ELSE",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // ELSE ::= 
            {
              String RESULT =null;
		RESULT ="";
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ELSE",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // WHILE ::= whilet openp CONDITION closep openb M0 BLOCK closeb 
            {
              String RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		SymbolCONDITION cond = (SymbolCONDITION)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
                    //go to to return to the condition at the end of the code
                    c.goTo(cond.getPre());
                    //label to end the while
                    c.label(cond.getEnd());
                    RESULT = b;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("WHILE",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // FOR ::= FORDEC CODE 
            {
              String RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		SymbolFORDEC fd = (SymbolFORDEC)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int codeleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int coderight = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		String code = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                c.goTo(fd.getPre());
                c.label(fd.getEnd());
                RESULT= code;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FOR",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // FORDEC ::= fort openp M0 DECL comma CONDITIONFOR comma ASSIGN closep 
            {
              SymbolFORDEC RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		SymbolCONDITIONFOR cond = (SymbolCONDITIONFOR)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int preleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int preright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Integer pre = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
            c.goTo(cond.getPre());
            c.label(cond.getStart());
            RESULT = new SymbolFORDEC(pre,cond.getEnd());

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("FORDEC",43, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-8)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // CODE ::= openb BLOCK closeb 
            {
              String RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
            RESULT = b;
        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CODE",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // DECL ::= DECLARATION 
            {
              Object RESULT =null;
		int decleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int decright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer dec = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                   var serr = new SymbolError();
                                   if(dec == Description.dConstant){
                                        report_fatal_error("Constant in for ",serr);
                                   }else
                                   if(dec == -1){
                                        report_fatal_error("Declaration without assignation ",serr);

                                   }


                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // DECL ::= 
            {
              Object RESULT =null;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECL",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // M4 ::= 
            {
              Integer RESULT =null;
		
        int pre = c.nextLabel();
        c.label(pre);
        RESULT = pre;

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M4",48, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // ASSIGN ::= M4 ASSIGNATION 
            {
              Integer RESULT =null;
		int preleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int preright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Integer pre = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolASSIGNATION v = (SymbolASSIGNATION)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                var serr = new SymbolError();
                                if(v.getType().equals(Description.TypeTuple)){
                                    report_fatal_error("Tuple in for ",serr);
                                    errorSemantic = true;
                                }else
                                RESULT = pre;
                            
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASSIGN",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // ASSIGN ::= M4 
            {
              Integer RESULT =null;
		int preleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int preright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer pre = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		RESULT = pre;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("ASSIGN",25, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // M5 ::= 
            {
              Integer RESULT =null;
		
            int pre = c.nextLabel();
            c.label(pre);
            RESULT = pre;
 
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("M5",49, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // CONDITION ::= M5 E 
            {
              SymbolCONDITION RESULT =null;
		int preleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int preright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Integer pre = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolE e = (SymbolE)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                                                var serr = new SymbolError();
                                                if(!e.getType().equals(Description.TypeBool)){
                                                    report_fatal_error("Condition must be boolean ",serr);
                                                    errorSemantic = true;
                                                }else{
                                                    int end = c.nextLabel();
                                                    c.conditional(e.getR(),end);
                                                    RESULT = new SymbolCONDITION(pre,end);
                                                }


                                        
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDITION",41, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // CONDITIONFOR ::= CONDITION 
            {
              SymbolCONDITIONFOR RESULT =null;
		int condleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		SymbolCONDITION cond = (SymbolCONDITION)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
                //we place the goTo to go to the start of the execution of the for (skipping the assignation)
                int goTo = c.nextLabel();
                c.goTo(goTo);
                RESULT = new SymbolCONDITIONFOR(cond ,goTo);

              CUP$Parser$result = parser.getSymbolFactory().newSymbol("CONDITIONFOR",42, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$Parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
              return CUP$Parser$do_action_part00000000(
                               CUP$Parser$act_num,
                               CUP$Parser$parser,
                               CUP$Parser$stack,
                               CUP$Parser$top);
    }
}

}
